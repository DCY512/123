# -*- coding: utf-8 -*-
import time
from PyQt5.QtWidgets import QApplication , QMainWindow, QFileDialog,QMessageBox,QWidget,QHeaderView,QTableWidgetItem, QAbstractItemView
import sys
import os
from PIL import ImageFont
from PyQt5.uic.properties import QtCore
from ultralytics import YOLO
sys.path.append('UIProgram')
from UIProgram.UiMain import Ui_MainWindow
import sys
from PyQt5.QtCore import QTimer, Qt, QThread, pyqtSignal,QCoreApplication
import detect_tools as tools
import cv2
import Config
from UIProgram.QssLoader import QSSLoader
from UIProgram.precess_bar import ProgressBar
import numpy as np
# import torch
from PyQt5.QtCore import pyqtSlot, QIODevice, QByteArray
from PyQt5.QtSerialPort import QSerialPortInfo, QSerialPort
from PyQt5 import QtWidgets, QtCore  #窗口调试
import re
import json

class MainWindow(QMainWindow):
    x_updated = pyqtSignal(int)
    y_updated = pyqtSignal(int)
    def __init__(self, parent=None):
        super(QMainWindow, self).__init__(parent)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.initMain()
        self.signalconnect()
        self._serial = QSerialPort(self)
        self._ports = {}  # 确保 _ports 变量初始化
        self.getAvailablePorts()

        # 加载css渲染效果
        style_file = 'UIProgram/style.css'
        qssStyleSheet = QSSLoader.read_qss_file(style_file)
        self.setStyleSheet(qssStyleSheet)

        self.buffer = ""  # **缓存接收的数据**
        self.in_json = False


        self.ui.textBrowser.setReadOnly(False)

        # 按钮连接
        self.ui.pushButton.clicked.connect(self.on_buttonConnect_clicked)
        self._serial.readyRead.connect(self.read_serial_data)  # 连接串口数据接收信号

        self.weizhi_X = None  # 存储X结尾的数据
        self.weizhi_Y = None  # 存储Y结尾的数据

        self.at_commands = [
            # {"cmd": "AT+RESTORE", "delay": 1000},  # 恢复默认设置，延时1秒
            {"cmd": "AT+CWMODE=1", "delay": 1000},  # 设置WiFi模式，延时1秒
            {"cmd": "AT+CWJAP=\"DCY\",\"12345678\"", "delay": 5000},  # 连接WiFi，延时5秒
            {"cmd": "AT+CIPSNTPCFG=1,8,\"ntp1.aliyun.com\"", "delay": 2000},  # 配置SNTP，延时2秒
            {
                "cmd": "AT+MQTTUSERCFG=0,1,\"NULL\",\"PYQT&iggisf93NrW\",\"3870efe14bdc3ebccae0d6778404635cbcdb79eb06273b0224bdb1321eb5ffd6\",0,0,\"\"",
                "delay": 2000},
            {
                "cmd": "AT+MQTTCLIENTID=0,\"iggisf93NrW.PYQT|securemode=2\,signmethod=hmacsha256\,timestamp=1741496379578|\"",
                "delay": 2000},
            {"cmd": "AT+MQTTCONN=0,\"iot-06z00emlemujeca.mqtt.iothub.aliyuncs.com\",1883,1", "delay": 3000},
            # 连接MQTT服务器，延时3秒
            {"cmd": "AT+MQTTSUB=0,\"/iggisf93NrW/PYQT/user/get\",1", "delay": 1000},  # 订阅主题，延时1秒
            {
                "cmd": "AT+MQTTPUB=0,\"/sys/iggisf93NrW/PYQT/thing/event/property/post\",\"{\\\"params\\\":{\\\"DCYX\\\":0}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒
            {
                "cmd": "AT+MQTTPUB=0,\"/sys/iggisf93NrW/PYQT/thing/event/property/post\",\"{\\\"params\\\":{\\\"DCYY\\\":0}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒
            {
                "cmd": "AT+MQTTPUB=0,\"/sys/iggisf93NrW/PYQT/thing/event/property/post\",\"{\\\"params\\\":{\\\"HUO\\\":0}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒
            {
                "cmd": "AT+MQTTPUB=0,\"/iggisf93NrW/PYQT/user/update\",\"{\\\"params\\\":{\\\"HUO\\\":0}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒

        ]
        self.current_cmd_index = 0  # 当前发送的指令索引

        self.HUO = [
            {
                "cmd": "AT+MQTTPUB=0,\"/sys/iggisf93NrW/PYQT/thing/event/property/post\",\"{\\\"params\\\":{\\\"HUO\\\":1}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒
            {
                "cmd": "AT+MQTTPUB=0,\"/iggisf93NrW/PYQT/user/update\",\"{\\\"params\\\":{\\\"HUO\\\":1}}\",1,0",
                "delay": 1000},  # 发布MQTT消息，延时1秒
        ]
        self.HUOlistID = 0
        # 新增方法：启动发送AT指令队列

        self.ui.weizhi_X.setText("0")
        self.ui.weizhi_Y.setText("0")
        self.x_updated.connect(lambda x: self.ui.weizhi_X.setText(str(x)))
        self.y_updated.connect(lambda y: self.ui.weizhi_Y.setText(str(y)))
        #测试
    def HUO_start_send_at_commands(self):
        if self._serial.isOpen() and self.HUOlistID < len(self.HUO):
            # 获取当前指令和延时
            HUO_current_cmd = self.HUO[self.HUOlistID]
            HUO_cmd = HUO_current_cmd["cmd"]
            HUO_delay = HUO_current_cmd["delay"]

            # 发送当前指令
            self.HUO_send_at_command(HUO_cmd)

            # 设置下一个指令的延时
            self.HUOlistID += 1
            QTimer.singleShot(HUO_delay, self.HUO_start_send_at_commands)
        else:
            self.HUOlistID = 0  # 重置索引

        # 新增方法：发送单个AT指令

    def HUO_send_at_command(self, HUO_cmd):
        if self._serial.isOpen():
            # 添加换行符 "\r\n" 确保指令被解析
            HUO_full_cmd = HUO_cmd + "\r\n"
            HUO_bytes_written = self._serial.write(HUO_full_cmd.encode())
            if HUO_bytes_written == len(HUO_full_cmd):
                self.ui.textBrowser.append(f'[发送成功] {HUO_cmd}')
            else:
                self.ui.textBrowser.append(f'[发送失败] {HUO_cmd}')






    def start_send_at_commands(self):
        if self._serial.isOpen() and self.current_cmd_index < len(self.at_commands):
            # 获取当前指令和延时
            current_cmd = self.at_commands[self.current_cmd_index]
            cmd = current_cmd["cmd"]
            delay = current_cmd["delay"]

            # 发送当前指令
            self.send_at_command(cmd)

            # 设置下一个指令的延时
            self.current_cmd_index += 1
            QTimer.singleShot(delay, self.start_send_at_commands)
        else:
            self.current_cmd_index = 0  # 重置索引

        # 新增方法：发送单个AT指令

    def send_at_command(self, cmd):
        if self._serial.isOpen():
            # 添加换行符 "\r\n" 确保指令被解析
            full_cmd = cmd + "\r\n"
            bytes_written = self._serial.write(full_cmd.encode())
            if bytes_written == len(full_cmd):
                self.ui.textBrowser.append(f'[发送成功] {cmd}')
            else:
                self.ui.textBrowser.append(f'[发送失败] {cmd}')

    def read_serial_data(self):
        while self._serial.bytesAvailable():
            data = self._serial.readAll().data().decode().strip()
            self.parse_serial_data(data)

    def parse_serial_data(self, data):
        """
        解析串口/MQTT数据，直接提取DCYX/DCYY后的数值（不依赖JSON解析）
        """
        self.buffer += data.strip()
        pattern = r'(DCYX|DCYY)\D*(\d+)'
        matches = re.findall(pattern, self.buffer)

        if matches:
            # 遍历所有匹配项，根据关键字反向赋值
            for keyword, val in matches:
                try:
                    # 转换字符串为整数
                    num_val = int(val)
                    if keyword == 'DCYX':
                        self.weizhi_X = num_val
                        self.ui.weizhi_X.setText(str(num_val))  # 更新X坐标显示
                    elif keyword == 'DCYY':
                        self.weizhi_Y = num_val
                        self.ui.weizhi_Y.setText(str(num_val))  # 更新Y坐标显示
                except ValueError:
                    print(f"无效数值: {val}")

            # 清空已处理缓存
            self.buffer = self.buffer.split(matches[-1] + matches[-1])[-1]

        # 防缓存溢出逻辑
        elif len(self.buffer) > 1024:
            print("缓存溢出，自动清空")
            self.buffer = ""
        if keyword == 'DCYX':
            self.weizhi_X = num_val
            self.x_updated.emit(num_val)
        elif keyword == 'DCYY':
            self.weizhi_Y = num_val
            self.y_updated.emit(num_val)
        # 控制台打印验证
        print(f"当前坐标 - X: {self.weizhi_X}, Y: {self.weizhi_Y}")

    def getAvailablePorts(self):
        self._ports.clear()
        self.ui.comboBox11.clear()
        for info in QSerialPortInfo.availablePorts():
            self._ports[info.portName()] = info
            self.ui.comboBox11.addItem(info.portName())

    def closeEvent(self, event):
        if self._serial.isOpen():
            self._serial.close()
        super(QMainWindow, self).closeEvent(event)

    def on_buttonConnect_clicked(self):
        # 如果串口已经打开，则关闭它
        if self._serial.isOpen():
            self._serial.close()
            self.ui.textBrowser.append('串口已关闭')
            self.ui.pushButton.setText('打开串口')
            return

        # 获取选中的串口名称
        name = self.ui.comboBox11.currentText()
        if not name or name not in self._ports:
            QMessageBox.critical(self, '错误', '没有选择有效的串口')
            return

        port = self._ports[name]
        self._serial.setPortName(port.systemLocation())

        try:
            # 获取串口参数，注意：确保下拉框中显示的文本与 QSerialPort 枚举名称的后缀一致
            baud_rate = getattr(QSerialPort, 'Baud' + self.ui.comboBoxbaud.currentText(), None)
            parity = getattr(QSerialPort, self.ui.comboBoxparity.currentText() + 'Parity', None)
            data_bits = getattr(QSerialPort, 'Data' + self.ui.comboBoxdata.currentText(), None)
            stop_bits = getattr(QSerialPort, self.ui.comboBoxstop.currentText(), None)

            if None in (baud_rate, parity, data_bits, stop_bits):
                raise AttributeError('无效的串口参数')

            self._serial.setBaudRate(baud_rate)
            self._serial.setParity(parity)
            self._serial.setDataBits(data_bits)
            self._serial.setStopBits(stop_bits)
        except AttributeError as e:
            QMessageBox.critical(self, '配置错误', f'无效的串口参数: {str(e)}')
            return

        self._serial.setFlowControl(QSerialPort.NoFlowControl)

        if self._serial.open(QIODevice.ReadWrite):
            self.ui.textBrowser.append('打开串口成功')
            self.ui.pushButton.setText('关闭串口')

            # 启动AT指令队列发送
            self.current_cmd_index = 0  # 重置索引
            self.start_send_at_commands()  # 开始发送
        else:
            QMessageBox.critical(self, '错误', f'打开串口失败: {self._serial.errorString()}')

    def signalconnect(self):
        # 连接各个控件的信号和槽函数，注意控件名称应与 UI 中定义的一致
        self.ui.PicBtn.clicked.connect(self.open_img)
        self.ui.comboBox.activated.connect(self.combox_change)
        self.ui.VideoBtn.clicked.connect(self.vedio_show)
        self.ui.CapBtn.clicked.connect(self.camera_show)
        self.ui.SaveBtn.clicked.connect(self.save_detect_video)
        self.ui.ExitBtn.clicked.connect(QCoreApplication.quit)
        self.ui.FilesBtn.clicked.connect(self.detact_batch_imgs)

    def initMain(self):
        self.show_width = 770
        self.show_height = 480

        self.org_path = None

        self.is_camera_open = False
        self.cap = None

        # self.device = 0 if torch.cuda.is_available() else 'cpu'

        # 加载检测模型
        self.model = YOLO(Config.model_path, task='detect')
        self.model(np.zeros((48, 48, 3)))  #预先加载推理模型
        self.fontC = ImageFont.truetype("Font/platech.ttf", 25, 0)

        # 用于绘制不同颜色矩形框
        self.colors = tools.Colors()

        # 更新视频图像
        self.timer_camera = QTimer()

        # 更新检测信息表格
        # self.timer_info = QTimer()
        # 保存视频
        self.timer_save_video = QTimer()

        # 表格
        self.ui.tableWidget.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.ui.tableWidget.verticalHeader().setDefaultSectionSize(40)
        self.ui.tableWidget.setColumnWidth(0, 80)  # 设置列宽
        self.ui.tableWidget.setColumnWidth(1, 200)
        self.ui.tableWidget.setColumnWidth(2, 150)
        self.ui.tableWidget.setColumnWidth(3, 90)
        self.ui.tableWidget.setColumnWidth(4, 230)
        # self.ui.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)  # 表格铺满
        # self.ui.tableWidget.horizontalHeader().setSectionResizeMode(0, QHeaderView.Interactive)
        # self.ui.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)  # 设置表格不可编辑
        self.ui.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)  # 设置表格整行选中
        self.ui.tableWidget.verticalHeader().setVisible(False)  # 隐藏列标题
        self.ui.tableWidget.setAlternatingRowColors(True)  # 表格背景交替

        # 设置主页背景图片border-image: url(:/icons/ui_imgs/icons/camera.png)
        # self.setStyleSheet("#MainWindow{background-image:url(:/bgs/ui_imgs/bg3.jpg)}")

    def open_img(self):
        if self.cap:
            # 打开图片前关闭摄像头
            self.video_stop()
            self.is_camera_open = False
            self.ui.CaplineEdit.setText('摄像头未开启')
            self.cap = None

        # 弹出的窗口名称：'打开图片'
        # 默认打开的目录：'./'
        # 只能打开.jpg与.gif结尾的图片文件
        # file_path, _ = QFileDialog.getOpenFileName(self.ui.centralwidget, '打开图片', './', "Image files (*.jpg *.gif)")
        file_path, _ = QFileDialog.getOpenFileName(None, '打开图片', './', "Image files (*.jpg *.jepg *.png)")
        if not file_path:
            return

        self.ui.comboBox.setDisabled(False)
        self.org_path = file_path
        self.org_img = tools.img_cvread(self.org_path)

        # 目标检测
        t1 = time.time()
        self.results = self.model(self.org_path)[0]
        t2 = time.time()
        take_time_str = '{:.3f} s'.format(t2 - t1)
        self.ui.time_lb.setText(take_time_str)

        location_list = self.results.boxes.xyxy.tolist()
        self.location_list = [list(map(int, e)) for e in location_list]
        cls_list = self.results.boxes.cls.tolist()
        self.cls_list = [int(i) for i in cls_list]
        self.conf_list = self.results.boxes.conf.tolist()
        self.conf_list = ['%.2f %%' % (each*100) for each in self.conf_list]

        total_nums = len(location_list)
        cls_percents = []
        for i in range(6):
            res = self.cls_list.count(i) / total_nums
            cls_percents.append(res)
        self.set_percent(cls_percents)

        # now_img = self.cv_img.copy()
        # for loacation, type_id, conf in zip(self.location_list, self.cls_list, self.conf_list):
        #     type_id = int(type_id)
        #     color = self.colors(int(type_id), True)
        #     # cv2.rectangle(now_img, (int(x1), int(y1)), (int(x2), int(y2)), colors(int(type_id), True), 3)
        #     now_img = tools.drawRectBox(now_img, loacation, Config.CH_names[type_id], self.fontC, color)
        now_img = self.results.plot()
        self.draw_img = now_img
        # 获取缩放后的图片尺寸
        self.img_width, self.img_height = self.get_resize_size(now_img)
        resize_cvimg = cv2.resize(now_img,(self.img_width, self.img_height))
        pix_img = tools.cvimg_to_qpiximg(resize_cvimg)
        self.ui.label_show.setPixmap(pix_img)
        self.ui.label_show.setAlignment(Qt.AlignCenter)
        # 设置路径显示
        self.ui.PiclineEdit.setText(self.org_path)

        # 目标数目
        target_nums = len(self.cls_list)
        self.ui.label_nums.setText(str(target_nums))

        # 设置目标选择下拉框
        choose_list = ['全部']
        target_names = [Config.names[id]+ '_'+ str(index) for index,id in enumerate(self.cls_list)]
        # object_list = sorted(set(self.cls_list))
        # for each in object_list:
        #     choose_list.append(Config.CH_names[each])
        choose_list = choose_list + target_names


        self.ui.comboBox.clear()
        self.ui.comboBox.addItems(choose_list)

        if target_nums >= 1:
            self.ui.type_lb.setText(Config.CH_names[self.cls_list[0]])

            self.ui.label_conf.setText(str(self.conf_list[0]))
        #   默认显示第一个目标框坐标
        #   设置坐标位置值
            self.ui.label_xmin.setText(str(self.location_list[0][0]))
            self.ui.label_ymin.setText(str(self.location_list[0][1]))
            self.ui.label_xmax.setText(str(self.location_list[0][2]))
            self.ui.label_ymax.setText(str(self.location_list[0][3]))
        else:
            self.ui.type_lb.setText('')
            self.ui.label_conf.setText('')
            self.ui.label_xmin.setText('')
            self.ui.label_ymin.setText('')
            self.ui.label_xmax.setText('')
            self.ui.label_ymax.setText('')

        # # 删除表格所有行
        self.ui.tableWidget.setRowCount(0)
        self.ui.tableWidget.clearContents()
        self.tabel_info_show(self.location_list, self.cls_list, self.conf_list,path=self.org_path)


    def detact_batch_imgs(self):
        if self.cap:
            # 打开图片前关闭摄像头
            self.video_stop()
            self.is_camera_open = False
            self.ui.CaplineEdit.setText('摄像头未开启')
            self.cap = None
        directory = QFileDialog.getExistingDirectory(self,
                                                      "选取文件夹",
                                                      "./")  # 起始路径
        if not  directory:
            return
        self.org_path = directory
        img_suffix = ['jpg','png','jpeg','bmp']
        for file_name in os.listdir(directory):
            full_path = os.path.join(directory,file_name)
            if os.path.isfile(full_path) and file_name.split('.')[-1].lower() in img_suffix:
                # self.ui.comboBox.setDisabled(False)
                img_path = full_path
                self.org_img = tools.img_cvread(img_path)
                # 目标检测
                t1 = time.time()
                self.results = self.model(img_path)[0]
                t2 = time.time()
                take_time_str = '{:.3f} s'.format(t2 - t1)
                self.ui.time_lb.setText(take_time_str)

                location_list = self.results.boxes.xyxy.tolist()
                self.location_list = [list(map(int, e)) for e in location_list]
                cls_list = self.results.boxes.cls.tolist()
                self.cls_list = [int(i) for i in cls_list]
                self.conf_list = self.results.boxes.conf.tolist()
                self.conf_list = ['%.2f %%' % (each * 100) for each in self.conf_list]

                total_nums = len(location_list)
                cls_percents = []
                for i in range(6):
                    res = self.cls_list.count(i) / total_nums
                    cls_percents.append(res)
                self.set_percent(cls_percents)

                now_img = self.results.plot()

                self.draw_img = now_img
                # 获取缩放后的图片尺寸
                self.img_width, self.img_height = self.get_resize_size(now_img)
                resize_cvimg = cv2.resize(now_img, (self.img_width, self.img_height))
                pix_img = tools.cvimg_to_qpiximg(resize_cvimg)
                self.ui.label_show.setPixmap(pix_img)
                self.ui.label_show.setAlignment(Qt.AlignCenter)
                # 设置路径显示
                self.ui.PiclineEdit.setText(img_path)

                # 目标数目
                target_nums = len(self.cls_list)
                self.ui.label_nums.setText(str(target_nums))
                print("检测到的类别：", [Config.CH_names[cls] for cls in self.cls_list])

                # 设置目标选择下拉框
                choose_list = ['全部']
                target_names = [Config.names[id] + '_' + str(index) for index, id in enumerate(self.cls_list)]
                choose_list = choose_list + target_names

                self.ui.comboBox.clear()
                self.ui.comboBox.addItems(choose_list)

                if target_nums >= 1:
                    self.ui.type_lb.setText(Config.CH_names[self.cls_list[0]])
                    self.ui.label_conf.setText(str(self.conf_list[0]))
                    #   默认显示第一个目标框坐标
                    #   设置坐标位置值
                    self.ui.label_xmin.setText(str(self.location_list[0][0]))
                    self.ui.label_ymin.setText(str(self.location_list[0][1]))
                    self.ui.label_xmax.setText(str(self.location_list[0][2]))
                    self.ui.label_ymax.setText(str(self.location_list[0][3]))
                else:
                    self.ui.type_lb.setText('')
                    self.ui.label_conf.setText('')
                    self.ui.label_xmin.setText('')
                    self.ui.label_ymin.setText('')
                    self.ui.label_xmax.setText('')
                    self.ui.label_ymax.setText('')

                # # 删除表格所有行
                # self.ui.tableWidget.setRowCount(0)
                # self.ui.tableWidget.clearContents()
                self.tabel_info_show(self.location_list, self.cls_list, self.conf_list, path=img_path)
                self.ui.tableWidget.scrollToBottom()
                QApplication.processEvents()  #刷新页面

    def draw_rect_and_tabel(self, results, img):
        now_img = img.copy()
        location_list = results.boxes.xyxy.tolist()
        self.location_list = [list(map(int, e)) for e in location_list]
        cls_list = results.boxes.cls.tolist()
        self.cls_list = [int(i) for i in cls_list]
        self.conf_list = results.boxes.conf.tolist()
        self.conf_list = ['%.2f %%' % (each * 100) for each in self.conf_list]

        for loacation, type_id, conf in zip(self.location_list, self.cls_list, self.conf_list):
            type_id = int(type_id)
            color = self.colors(int(type_id), True)
            # cv2.rectangle(now_img, (int(x1), int(y1)), (int(x2), int(y2)), colors(int(type_id), True), 3)
            now_img = tools.drawRectBox(now_img, loacation, Config.CH_names[type_id], self.fontC, color)

        # 获取缩放后的图片尺寸
        self.img_width, self.img_height = self.get_resize_size(now_img)
        resize_cvimg = cv2.resize(now_img, (self.img_width, self.img_height))
        pix_img = tools.cvimg_to_qpiximg(resize_cvimg)
        self.ui.label_show.setPixmap(pix_img)
        self.ui.label_show.setAlignment(Qt.AlignCenter)
        # 设置路径显示
        self.ui.PiclineEdit.setText(self.org_path)

        # 目标数目
        target_nums = len(self.cls_list)
        self.ui.label_nums.setText(str(target_nums))
        if target_nums >= 1:
            self.ui.type_lb.setText(Config.CH_names[self.cls_list[0]])
            self.ui.label_conf.setText(str(self.conf_list[0]))
            self.ui.label_xmin.setText(str(self.location_list[0][0]))
            self.ui.label_ymin.setText(str(self.location_list[0][1]))
            self.ui.label_xmax.setText(str(self.location_list[0][2]))
            self.ui.label_ymax.setText(str(self.location_list[0][3]))
        else:
            self.ui.type_lb.setText('')
            self.ui.label_conf.setText('')
            self.ui.label_xmin.setText('')
            self.ui.label_ymin.setText('')
            self.ui.label_xmax.setText('')
            self.ui.label_ymax.setText('')

        # 删除表格所有行
        self.ui.tableWidget.setRowCount(0)
        self.ui.tableWidget.clearContents()
        self.tabel_info_show(self.location_list, self.cls_list, self.conf_list, path=self.org_path)
        return now_img

    def combox_change(self):
        com_text = self.ui.comboBox.currentText()
        if com_text == '全部':
            cur_box = self.location_list
            cur_img = self.results.plot()
            self.ui.type_lb.setText(Config.CH_names[self.cls_list[0]])
            self.ui.label_conf.setText(str(self.conf_list[0]))
        else:
            index = int(com_text.split('_')[-1])
            cur_box = [self.location_list[index]]
            cur_img = self.results[index].plot()
            self.ui.type_lb.setText(Config.CH_names[self.cls_list[index]])
            self.ui.label_conf.setText(str(self.conf_list[index]))

        # 设置坐标位置值
        self.ui.label_xmin.setText(str(cur_box[0][0]))
        self.ui.label_ymin.setText(str(cur_box[0][1]))
        self.ui.label_xmax.setText(str(cur_box[0][2]))
        self.ui.label_ymax.setText(str(cur_box[0][3]))

        resize_cvimg = cv2.resize(cur_img, (self.img_width, self.img_height))
        pix_img = tools.cvimg_to_qpiximg(resize_cvimg)
        self.ui.label_show.clear()
        self.ui.label_show.setPixmap(pix_img)
        self.ui.label_show.setAlignment(Qt.AlignCenter)


    def get_video_path(self):
        file_path, _ = QFileDialog.getOpenFileName(None, '打开视频', './', "Image files (*.avi *.mp4 *.jepg *.png)")
        if not file_path:
            return None
        self.org_path = file_path
        self.ui.VideolineEdit.setText(file_path)
        return file_path

    def video_start(self):
        # 删除表格所有行
        self.ui.tableWidget.setRowCount(0)
        self.ui.tableWidget.clearContents()

        # 清空下拉框
        self.ui.comboBox.clear()

        # 定时器开启，每隔一段时间，读取一帧
        self.timer_camera.start(1)
        self.timer_camera.timeout.connect(self.open_frame)

    def tabel_info_show(self, locations, clses, confs, path=None):
        path = path
        for location, cls, conf in zip(locations, clses, confs):
            row_count = self.ui.tableWidget.rowCount()  # 返回当前行数(尾部)
            self.ui.tableWidget.insertRow(row_count)  # 尾部插入一行
            item_id = QTableWidgetItem(str(row_count+1))  # 序号
            item_id.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)  # 设置文本居中
            item_path = QTableWidgetItem(str(path))  # 路径
            # item_path.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            item_cls = QTableWidgetItem(str(Config.CH_names[cls]))
            item_cls.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)  # 设置文本居中

            item_conf = QTableWidgetItem(str(conf))
            item_conf.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)  # 设置文本居中

            item_location = QTableWidgetItem(str(location)) # 目标框位置
            # item_location.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)  # 设置文本居中

            self.ui.tableWidget.setItem(row_count, 0, item_id)
            self.ui.tableWidget.setItem(row_count, 1, item_path)
            self.ui.tableWidget.setItem(row_count, 2, item_cls)
            self.ui.tableWidget.setItem(row_count, 3, item_conf)
            self.ui.tableWidget.setItem(row_count, 4, item_location)
        self.ui.tableWidget.scrollToBottom()

    def video_stop(self):
        self.cap.release()
        self.timer_camera.stop()
        # self.timer_info.stop()

    def open_frame(self):
        ret, now_img = self.cap.read()
        if ret:
            try:
                # 目标检测
                t1 = time.time()
                results = self.model(now_img)[0]
                t2 = time.time()
                take_time_str = '{:.3f} s'.format(t2 - t1)
                self.ui.time_lb.setText(take_time_str)

                # 获取检测结果（目标框位置，类别，置信度）
                location_list = results.boxes.xyxy.tolist()
                self.location_list = [list(map(int, e)) for e in location_list]
                cls_list = results.boxes.cls.tolist()
                self.cls_list = [int(i) for i in cls_list]
                conf_list = results.boxes.conf.tolist()

                # 过滤掉置信度低于 0.7 的目标（仅做记录和过滤，不发送）
                filtered_locations = []
                filtered_cls_list = []
                filtered_conf_list = []
                sendnum_list = []  # 用来保存发送的类别索引

                for i in range(len(conf_list)):
                    if conf_list[i] >= 0.7:  # 只有置信度大于或等于 0.7 的目标才会被发送
                        sendnum_list.append(self.cls_list[i])
                    # 保留所有目标（无论置信度高低）
                    filtered_locations.append(self.location_list[i])
                    filtered_cls_list.append(self.cls_list[i])
                    filtered_conf_list.append(conf_list[i])

                # 更新经过过滤后的目标信息
                self.location_list = filtered_locations
                self.cls_list = filtered_cls_list
                self.conf_list = filtered_conf_list

                # 将 sendnum_list 中的类别索引作为文本内容发送
                textsend = ','.join(map(str, sendnum_list))  # 将类别索引列表转换为字符串
                if textsend:
                    self.HUOlistID = 0  # 重置索引
                    self.HUO_start_send_at_commands()  # 开始发送

                # 计算类别分布百分比
                total_nums = len(self.location_list)
                cls_percents = []
                for i in range(6):
                    if total_nums != 0:  # 如果检测到目标
                        res = self.cls_list.count(i) / total_nums
                    else:
                        res = 0
                    cls_percents.append(res)
                self.set_percent(cls_percents)

                # 绘制检测结果，只有置信度 >= 0.7 才绘制目标框
                now_img = results.plot()

                # 获取缩放后的图片尺寸
                self.img_width, self.img_height = self.get_resize_size(now_img)
                resize_cvimg = cv2.resize(now_img, (self.img_width, self.img_height))
                pix_img = tools.cvimg_to_qpiximg(resize_cvimg)
                self.ui.label_show.setPixmap(pix_img)
                self.ui.label_show.setAlignment(Qt.AlignCenter)

                # 目标数目
                target_nums = len(self.cls_list)
                self.ui.label_nums.setText(str(target_nums))

                # 设置目标选择下拉框
                choose_list = ['全部']
                target_names = [Config.names[id] + '_' + str(index) for index, id in enumerate(self.cls_list)]
                choose_list = choose_list + target_names

                self.ui.comboBox.clear()
                self.ui.comboBox.addItems(choose_list)

                # 显示第一个目标的相关信息
                if target_nums >= 1:
                    self.ui.type_lb.setText(Config.CH_names[self.cls_list[0]])
                    self.ui.label_conf.setText(str(self.conf_list[0]))
                    self.ui.label_xmin.setText(str(self.location_list[0][0]))
                    self.ui.label_ymin.setText(str(self.location_list[0][1]))
                    self.ui.label_xmax.setText(str(self.location_list[0][2]))
                    self.ui.label_ymax.setText(str(self.location_list[0][3]))
                else:
                    self.ui.type_lb.setText('')
                    self.ui.label_conf.setText('')
                    self.ui.label_xmin.setText('')
                    self.ui.label_ymin.setText('')
                    self.ui.label_xmax.setText('')
                    self.ui.label_ymax.setText('')

                # 更新表格信息
                self.tabel_info_show(self.location_list, self.cls_list, self.conf_list, path=self.org_path)

            except Exception as e:
                # 捕获并打印异常，避免闪退
                print(f"Error occurred: {str(e)}")

        else:
            self.cap.release()
            self.timer_camera.stop()

    def send_data_over_serial(self, textsend):
        # 向串口发送数据
        send_str = textsend + '\n'  # 用换行符分隔，确保数据以换行结束
        print(f"准备发送的数据: {send_str}")  # 打印发送数据的内容，供调试

        if self._serial.isOpen():
            bytes_written = self._serial.write(send_str.encode())
            if bytes_written == len(send_str):
                # 成功发送，显示发送的内容
                self.ui.textBrowser.append(f'发送数据: {send_str}')  # 将发送的数据打印到 textBrowser
            else:
                self.ui.textBrowser.append('发送数据失败')
        else:
            self.ui.textBrowser.append('串口未打开')

    def vedio_show(self):
        if self.is_camera_open:
            self.is_camera_open = False
            self.ui.CaplineEdit.setText('摄像头未开启')

        video_path = self.get_video_path()
        if not video_path:
            return None
        self.cap = cv2.VideoCapture(video_path)
        self.video_start()
        self.ui.comboBox.setDisabled(True)

    def camera_show(self):
        self.is_camera_open = not self.is_camera_open
        if self.is_camera_open:
            self.ui.CaplineEdit.setText('摄像头开启')
            self.cap = cv2.VideoCapture(0)
            self.video_start()
            self.ui.comboBox.setDisabled(True)
        else:
            self.ui.CaplineEdit.setText('摄像头未开启')
            self.ui.label_show.setText('')
            if self.cap:
                self.cap.release()
                cv2.destroyAllWindows()
            self.ui.label_show.clear()

    def get_resize_size(self, img):
        _img = img.copy()
        img_height, img_width , depth= _img.shape
        ratio = img_width / img_height
        if ratio >= self.show_width / self.show_height:
            self.img_width = self.show_width
            self.img_height = int(self.img_width / ratio)
        else:
            self.img_height = self.show_height
            self.img_width = int(self.img_height * ratio)
        return self.img_width, self.img_height

    def save_detect_video(self):
        return
    def update_process_bar(self,cur_num, total):
        if cur_num == 1:
            self.progress_bar = ProgressBar(self)
            self.progress_bar.show()
        if cur_num >= total:
            self.progress_bar.close()
            QMessageBox.about(self, '提示', '视频保存成功!\n文件在{}目录下'.format(Config.save_path))
            return
        if self.progress_bar.isVisible() is False:
            # 点击取消保存时，终止进程
            self.btn2Thread_object.stop()
            return
        value = int(cur_num / total *100)
        self.progress_bar.setValue(cur_num, total, value)
        QApplication.processEvents()

    def set_percent(self, probs):
        # 显示各表情概率值
        items = [self.ui.progressBar, self.ui.progressBar_2, self.ui.progressBar_3, self.ui.progressBar_4,
                 self.ui.progressBar_5, self.ui.progressBar_6]
        labels = [self.ui.label_20, self.ui.label_21, self.ui.label_22, self.ui.label_23,
                  self.ui.label_24, self.ui.label_25]
        prob_values = [round(each * 100) for each in probs]
        label_values = ['{:.1f}%'.format(each * 100) for each in probs]
        for i in range(len(probs)):
            items[i].setValue(prob_values[i])
            labels[i].setText(label_values[i])


class btn2Thread(QThread):
    """
    进行检测后的视频保存
    """
    # 声明一个信号
    update_ui_signal = pyqtSignal(int,int)

    def __init__(self, path, model, com_text):
        super(btn2Thread, self).__init__()
        self.org_path = path
        self.model = model
        self.com_text = com_text
        # 用于绘制不同颜色矩形框
        self.colors = tools.Colors()
        self.is_running = True  # 标志位，表示线程是否正在运行

    def run(self):
        # VideoCapture方法是cv2库提供的读取视频方法
        cap = cv2.VideoCapture(self.org_path)
        # 设置需要保存视频的格式“xvid”
        # 该参数是MPEG-4编码类型，文件名后缀为.avi
        fourcc = cv2.VideoWriter_fourcc(*'XVID')
        # 设置视频帧频
        fps = cap.get(cv2.CAP_PROP_FPS)
        # 设置视频大小
        size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))
        # VideoWriter方法是cv2库提供的保存视频方法
        # 按照设置的格式来out输出
        fileName = os.path.basename(self.org_path)
        name, end_name = fileName.split('.')
        save_name = name + '_detect_result.avi'
        save_video_path = os.path.join(Config.save_path, save_name)
        out = cv2.VideoWriter(save_video_path, fourcc, fps, size)

        prop = cv2.CAP_PROP_FRAME_COUNT
        total = int(cap.get(prop))
        print("[INFO] 视频总帧数：{}".format(total))
        cur_num = 0

        # 确定视频打开并循环读取
        while (cap.isOpened() and self.is_running):
            cur_num += 1
            print('当前第{}帧，总帧数{}'.format(cur_num, total))
            # 逐帧读取，ret返回布尔值
            # 参数ret为True 或者False,代表有没有读取到图片
            # frame表示截取到一帧的图片
            ret, frame = cap.read()
            if ret == True:
                # 检测
                results = self.model(frame)[0]
                frame = results.plot()
                out.write(frame)
                self.update_ui_signal.emit(cur_num, total)
            else:
                break
        # 释放资源
        cap.release()
        out.release()

    def stop(self):
        self.is_running = False




if __name__ == "__main__":
    QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)#窗口调试
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()

    sys.exit(app.exec_())
